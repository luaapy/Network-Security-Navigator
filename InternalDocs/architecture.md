# NSN Architecture Overview

**NSN (Network Security Navigator)** is a modern, extensible, cross‑platform scripting language designed for network‑security automation.  The interpreter is written in portable C99 and is split into a clear set of subsystems that can be built, tested, and replaced independently.

---

## 1. High‑Level Stack

| Layer | Responsibility |
|-------|-----------------|
| **Source** | `.nsn` files – UTF‑8 source code. |
| **Parser** | PEG‑generated parser (`nsn.gram`) produces an AST. |
| **Compiler** | Walks the AST, performs constant folding, and emits **bytecode**. |
| **Virtual Machine** | Stack‑based interpreter with a configurable value stack (`NSN_MAX_STACK_SIZE`). |
| **Garbage Collector** | Incremental mark‑and‑sweep (optional, controlled via `nsnconfig.h`). |
| **Standard Library** | Network, security, datetime, JSON, etc., implemented as C extensions. |
| **Embedding API** | `nsn.h`/`nsnconfig.h` expose `Nsn_Initialize`, `Nsn_RunFile`, etc. |

---

## 2. Core Subsystems

### 2.1 Parser & AST
* Generated by **PEG** (`nsn.gram`).
* Produces a tree of `nsn_ast_node` structs; each node carries source location for precise error reporting.

### 2.2 Compiler & Bytecode
* Emits a compact, register‑free instruction set (e.g., `LOAD_CONST`, `CALL_FUNCTION`, `JUMP_IF_FALSE`).
* Performs **peephole optimizations** (see `InternalDocs/optimization.md`).
* Supports **string interning** to reduce dictionary look‑ups.

### 2.3 Virtual Machine
* Stack‑based, similar to CPython’s evaluation loop.
* Each frame (`nsn_frame`) holds locals, globals, a value stack, and a program counter.
* Opcodes are dispatched via a `switch` in `ceval.c`.
* Optional **JIT** path (controlled by `NSN_ENABLE_JIT`).

### 2.4 Memory Management
* **Arena allocator** for short‑lived objects (see `memory.h`).
* Reference‑counted objects with atomic helpers (`pycore_atomic.h`).
* Full **garbage collector** (`gc.c`) that can be toggled at runtime via `nsnconfig.h`.

### 2.5 Object System
* Base `nsn_object` with a pointer to a `nsn_type` struct.
* Built‑in types: `Int`, `Float`, `Bool`, `String`, `List`, `Dict`, `Function`, `Module`, plus network‑specific types (`IPAddr`, `Packet`).
* Type objects expose deallocation, representation, and hashing callbacks.

---

## 3. Platform Abstraction Layer
* **POSIX** (`unistd.h`, `sys/socket.h`) and **Windows** (`winsock2.h`) are wrapped in `Modules/_network/`.
* `nsnconfig.h` defines macros such as `NSN_PLATFORM_WINDOWS` or `NSN_PLATFORM_POSIX` to conditionally compile platform‑specific code.
* Android NDK support is provided via the `Android/` Gradle module.

---

## 4. Build System & Packaging
* **CMake** is the primary build generator; a fallback **Autotools** script exists for legacy environments.
* CI pipelines (GitHub Actions, Azure Pipelines) compile for Linux, macOS, Windows, and Android.
* Packaging targets include Docker, Snap, RPM, and Homebrew (see `pkg/`).

---

## 5. Extensibility & Embedding
* New modules are added by creating a `*_module.c` file that registers functions with `nsn_module_new`.
* The interpreter can be embedded in other applications via the public API in `nsn.h`.
* Runtime configuration (`nsnconfig.h`) allows toggling JIT, GC, logging levels, and sandboxing without recompilation.

---

## 6. Security Model
* All native extensions run under the **sandbox** flag (`sandbox_enabled`).
* File‑system and network access can be restricted to whitelisted directories or hosts.
* Exceptions are represented by a hierarchy of `nsn_exception` objects (see `errors.c`).

---

*This document is a living design reference; keep it in sync with code changes.*
