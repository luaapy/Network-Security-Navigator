#!/usr/bin/env python3
# NSN (Network Security Navigator)
# Copyright (c) NSN Contributors
# Licensed under MIT License
#
# File: clinic.py
# Description: Minimal "Argument Clinic" implementation for NSN.
#              Automatically generates nsn_get_args boilerplate from C comments.

import os
import sys
import re

CLINIC_BLOCK_RE = re.compile(r'/\*\[nsn clinic\]\s*(.*?)\s*\[nsn clinic end\]\*/', re.DOTALL)

def process_clinic(c_file):
    with open(c_file, 'r', encoding='utf-8') as f:
        content = f.read()

    def replace_clinic(match):
        spec = match.group(1).strip()
        lines = spec.split('\n')
        
        # Example Spec:
        # module: name
        # func: my_func
        # args: s(name), i(age)
        
        module = ""
        func_name = ""
        args = []
        
        for line in lines:
            if line.startswith('module:'):
                module = line.split(':')[1].strip()
            elif line.startswith('func:'):
                func_name = line.split(':')[1].strip()
            elif line.startswith('args:'):
                arg_spec = line.split(':')[1].strip()
                # Parse "s(name), i(age)"
                args = re.findall(r'(\w)\((\w+)\)', arg_spec)

        # Generate C Code
        fmt = "".join([a[0] for a in args])
        declarations = ""
        for a_type, a_name in args:
            c_type = "const char *" if a_type == 's' else "long"
            declarations += f"    {c_type} {a_name};\n"
        
        gen = f"/* Generated by clinic.py */\n"
        gen += declarations
        gen += f"    if (!nsn_get_args(args, \"{fmt}\", "
        gen += ", ".join([f"&{a[1]}" for a in args])
        gen += ")) return NULL;\n"
        gen += f"/* End of Generated Code */"
        
        return gen

    new_content = CLINIC_BLOCK_RE.sub(replace_clinic, content)
    
    if new_content != content:
        print(f"  Processed {c_file}")
        with open(c_file, 'w', encoding='utf-8') as f:
            f.write(new_content)

def main():
    if len(sys.argv) < 2:
        print("Usage: clinic.py <c_file_or_dir>")
        return

    path = sys.argv[1]
    if os.path.isfile(path):
        process_clinic(path)
    else:
        for root, dirs, files in os.walk(path):
            for f in files:
                if f.endswith('.c'):
                    process_clinic(os.path.join(root, f))

if __name__ == "__main__":
    main()
